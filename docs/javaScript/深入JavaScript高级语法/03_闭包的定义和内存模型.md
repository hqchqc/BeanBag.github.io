# 03\_闭包的定义和内存模型

## JavaScript 中函数是一等公民

在 JavaScript 中，函数是非常重要的，并且是一等公民，既然是一等公民，所必须具备的条件：

1. 函数可以作为另一个函数的参数
2. 函数可以作为另一个函数的返回值

### 函数作为另一个函数的参数

```javascript
function calc(num1, num2, fn) {
  fn(num1, num2);
}

function add(num1, num2) {
  console.log(num1 + num2);
}

function sub(num1, num2) {
  console.log(num1 - num2);
}

function mul(num1, num2) {
  console.log(num1 * num2);
}

calc(10, 20, add);
calc(10, 20, sub);
calc(10, 20, mul);
```

### 函数作为另一个函数的返回值

```javascript
function foo(num) {
  function bar(count) {
    console.log(num + count);
  }
  return bar;
}

const add5Fn = foo(5);
add5Fn(10);
```

### 高阶函数

一个函数如果接收另外一个函数作为参数，或者该函数会返回另外一个函数作为返回值的函数，那么这个函数就被称为高阶函数。

以上两个案例就是属于高阶函数。

区分函数与方法：

- 函数 function：独立的 function, 称之为函数
- 方法 method： 当我们的一个函数属于某一个对象时，我们称这个函数就是这个对象的方法

补充一些数组中的高阶函数：

- filte 方法，返回一个新数组，不改变原数组
- map 方法，作为映射存在，返回一个新数组
- forEach 方法，作为迭代存在，没有返回值
- find/findIndex 方法，返回第一个找到的数组元素或下标
- reduce 方法，累加方法

## JavaScript 中闭包的定义

闭包的概念出现于 60 年代，最早实现闭包的程序是 Scheme,那么我们就可以理解为什么 JavaScript 有闭包：

- 因为 JavaScript 中有大量的设计是来源于 Scheme 的；

这里先来看一下闭包的定义，分为两个方面：在计算机科学和在 JavaScript 中，因为闭包这个概念不止是在 JavaScript 中存在。

### 1. 计算机科学中(维基百科)

- 闭包(Closure), 又称词法闭包(Lexical Closure) 或函数闭包(function Closures);
- 是在支持头等函数的编程语言中，实现词法绑定的一种技术;
- 闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境(相当于一个符号查找表);
- 闭包跟函数最大的区别就在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行

### 2. MDN 对 JavaScript 闭包的解释

- 一个函数和对其周围状态(lexical environment,词法环境)的引用捆绑在一起(或者说函数被引用包围),这样的组合就是闭包;
- 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域;
- 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来;

### 3. coderwhy 的理解和总结

- 一个普通的函数 function,如果它可以访问外层作用域的自由变量，那么这个函数就是一个闭包;
- 从广义的角度来说：JavaScript 中的函数都是闭包;
- 从狭义的角度来说：JavaScript 中的一个函数，如果访问了外层作用域的变量，那么它是一个闭包;

## 理解闭包

先看以下代码：

```javascript
function foo() {
  function bar() {
    console.log("bar");
  }
  return bar;
}

var fn = foo();
fn();
```

执行过程：

1. 首先执行代码开始，有一个执行上下文栈(ECS)，还有一个 GO，之后又会创造出 GEC ，在 GEC 中有一个 VO 指向 GO 对象；
2. 编译阶段 GO 对象中已经有了 Date、String 等对象，然后是 foo 和 fn,fn 的值为 undefined，foo 由于是函数，会开辟一个内存空间，创造出一个函数对象，foo 的值就为内存地址，假设为 0xa00；
3. 执行阶段，首先要执行函数，会创造 FEC，这里创造的是 foo 的 FEC，FEC 里面有 VO 对象指向的是 AO，要注意的是，AO 对象什么时候创建的呢？应该是在执行之前，因为假如定义了很多个函数但是都没有被使用到，那么肯定不会都给创建 AO 对象的，当要执行到这个函数的时候才会去创建 AO 对象，有了 AO 对象就回去编译代码了；
4. 编译代码，填补 AO 对象里的内容，这时候 AO 对象就会存在一个 bar 值为 bar 的内存地址，假设为 0xb00,要注意，在编译 GO 阶段的时候并不会去解析这个的 bar 函数，但是会进行预解析；
5. 执行代码，foo 对象里面返回了 bar，所以这时候 GO 里面原本为 undefined 的 fn 此时变为了 0xb00,至此 foo 的 FEC 已经结束了，接着会把它弹出栈，并释放对应 foo 的 AO 对象和相关的变量；
6. 继续执行代码，该执行 fn()了，fn 的值为 0xb00,于是继续创建新的属于 bar 的 FEC,重新创建新的 bar 的 AO 对象，但是里面为空，编译阶段结束
7. 执行阶段，执行 bar 函数里面的 console 语句，输出 bar；
8. bar 的 FEC 结束，弹出栈，销毁相应的 AO 对象，执行结束；

执行图示：

![执行过程](https://raw.githubusercontent.com/hqchqc/staticRepo/master/images/20220505233727.png)
